---
title: "Communities Speak"
author: "Arielle Herman"
date: "1/19/2022"
output:
  pdf_document: default
  html_document: default
---

I guess this happens when the script hangs after trying to print a ggplot to the viewing panel, I hope that it actually finished updating.

```{r message=F, warning=F}
library(googledrive)
library(readxl)
library(tidyverse)
library(stringr)
library(haven)
library(rjson)
library(googlesheets4)
source("functions/fixup.R")
source("dictionary.R")
source("thresholds.R")

boroughs <- read_xlsx("../data/input/Borough_for_Arielle.xlsx") %>%
  rename_all(str_to_lower) %>% mutate_all(str_to_lower)

var_dict


survey <- readRDS("../data/processed/survey.rds")

```

# Var Dictionary
Combine with codebook in order to easily rename columns in the cleaned dataset

# Survey Questions Codebook

Get important metadata on each of the questions that facilitates wrangling

# Data Cleaning

```{r}
clean_data <- function(df = survey, col = NULL) {
  by_col <- lapply(setdiff(colnames(df), c("responseid", "recordeddate")), function(col) {
    
    
#for (col in colnames(survey)[-1]) {
    index <- which(survey_codebook$q == col)
    values <- as.integer(unlist(stringr::str_split(survey_codebook$options[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(survey_codebook$choices[index], "; "))
    
    recode_na <- str_detect(tags, "not applicable")
    
    if(any(all.equal(values, c(1,2)) == TRUE, !is.na(recode_na) & recode_na)) {
      df[[col]] <- 2 - as.integer(df[[col]] %>%
                                    # hard code 3 - not applicable
                                    na_if("3"))
      values <- (2 - values) %>% na_if(-1)
      
    }
    
    named <- setNames(values, tags) %>% na.omit
    
    if(col %in% c(likert, simple)) {
      out <- df[c("responseid", col)] %>%
        mutate_at(vars(col), ~labelled(as.integer(.), named))
    
      # multiple answer  
    } else if(col %in% mavr){
      
      sym_col <- sym(col)
      out <- df[c("responseid", col)] %>%
        fastDummies::dummy_cols(col, split = ",", ignore_na = TRUE) %>%
        tidytext::unnest_tokens(output = !!sym_col, token = "regex",
                                input = col, pattern = ",") %>%
        mutate_at(col, ~factor(as.integer(.), levels = values, labels = tags)) %>%
        group_by(responseid) %>% mutate_at(col, ~paste(., collapse = ";")) %>%
        distinct %>% na_if("NA")
      
      
      # don't double count prefer not to answer
      if(any(str_detect(tags, "prefer not to answer"))) {
        pnta <- which(names(named) == "prefer not to answer")
        pnta_col <- paste(c(col, pnta), collapse = "_")
        out <- out %>% mutate_at(pnta_col,
                          funs(ifelse(str_detect(!!sym_col, "prefer not to answer;|;prefer not to answer"),
                                      0, !!sym(pnta_col)))) %>%
          mutate_at(col, ~str_replace(., "prefer not to answer;|;prefer not to answer", ""))
      }
      
      # haven label dummies
      cols_to_label <- out %>% ungroup %>% select_if(is.numeric) %>% colnames
      relabelled <- lapply(cols_to_label, function(dummy){
        i <- as.integer(str_replace(dummy, paste0(col, "_"), ""))
        values <- c(0, 1)
        names(values) <- c(paste("not", tags[i]), tags[i])
        out %>% ungroup %>% transmute_at(dummy, ~labelled(as.integer(.), values))
      }) %>% reduce(bind_cols)
      
      out[cols_to_label] <- relabelled
      
      #r_zaiyctblk6t1z33
    } else if(all(!str_detect(df[[col]], "[:alpha:]"), na.rm = TRUE) & any(!is.na(df[[col]]))) {
      out <- df[c("responseid", col)] %>% mutate_at(vars(col), as.integer)
    } else {
      out <- df[c("responseid", col)]  
    }
    
# print(col)   
#}    
    return(out)
  })
  
  by_col %>% reduce(full_join, by = c("responseid")) %>%
    ### replace specific patterns in age and household questions
    mutate(q25_2 = str_replace(q25_2, "^62$", "1")) %>%
    mutate_at(vars(contains("25"), "q5"),
              ~str_replace_all(., pattern = str_c(dict$pattern, collapse = "|"), replacement = fixup)) %>%
    mutate(across(c(contains("25"), q5), ~as.double(str_extract(., "[:digit:]{1,2}"))))
  
}

final_clean <- survey[c('responseid', 'recordeddate')] %>% left_join(clean_data()) %>% left_join(distinct(boroughs %>% mutate(zip = as.character(zipcode))), by = c("q3" = "zip"))

# all NA if any NA
q35_sub <- final_clean %>% select(contains("35"))
q35_sub %>% transmute(mean = rowMeans(is.na(q35_sub))) %>% table


completion <- lapply(final_clean$responseid, function(id) {
#for(id in final_clean$responseid) {ghts
  row <- final_clean[final_clean$responseid == id, ] %>% select(contains("q")) %>%
    select(!matches("_"), contains("q25"), q41_1, q35_1, q34_1, q33_1)
  
  
  # employment logic
  if(!str_detect(row$q16, "unemp") | is.na(row$q16)) { # respondents who didn't mark unemployed
    row <- row %>% select(-q17, -q18)
  } else if(labelled::to_factor(row$q17) != "yes") {
    row <- row %>% select(-q18)
  }
  
  # household with children logic
  if(sum(row$q25_3, row$q25_4, na.rm = TRUE) == 0) { # respondents that don't have children
    row <- row %>% select(-q26, -q27, -q28, -q29, -q30, -q31)
  } else if(str_detect(row$q26, "home") & !str_detect(row$q26, ";") | is.na(row$q26)) { # respondents that only selected home school
    row <- row %>% select(-q27, -q28)
  } else if(row$q27 == 0 | is.na(row$q27)) { # respondents whose children aren't attending school in person
    row <- row %>% select(-q28)
  }
  
  if(row$q39 != 1 | is.na(row$q39)) {
    row <- row %>% select(-q40)
  }
  # residence logic
  ## will need to disqualify respondents not just based on completion, but also...
  if(row$q2 == 0 & !is.na(row$q2)) { # goes to the end because it removes all the columns (can't test the other conditions)
    row <- row %>% select(q2)
  }
  
  completion <- round(mean(!is.na(row)), digits = 6)
  return(completion)
}) %>% unlist

final_clean$completion <- completion

#hist(final_clean$completion)
#mean(!is.na(final_clean$q2))
save(final_clean, file = "../data/processed/final_clean.rdata")

```


## Brief Cleaning Process Validation?

# Wrangle

```{r}

# 39
index_41 <- str_which(column_names$q, "q41")
key_41 <- column_names$q[index_41]
label_41 <- column_names$label[index_41]
q41_bi <- final_clean %>% select(responseid, source, contains("41")) %>%
  mutate_at(vars(contains("41")), ~!str_detect(haven::as_factor(.), "almost|never")) #%>% rename_at(vars(contains("41")), ~glue::glue("{.x}_bi"))
names(q41_bi)[match(key_41, names(q41_bi))] <- paste(label_41, "bi", sep = "_")

remove_test <- final_clean %>% filter(if_any(everything(), ~str_detect(.x, "^test$")))

final_clean %>%
  transmute(across(contains("41"), ~!str_detect(haven::as_factor(.), "almost|never"), .names = "{col}_bi"))

wrangled <- final_clean %>% #mutate(completion = rowSums(!is.na(final_clean))/ncol(final_clean)) %>%
  # remove invalid responses
filter(completion >= min_completion,
         duration >= min_duration,
         q2 == 1,
         q5 > 17,
         borough != "long island") %>%
  anti_join(remove_test) %>%
  # make new variables
  mutate(
    #### race variables ####
    race_twomore = str_detect(q7, ";"),
    race_black_his = str_detect(q7, "black") & str_detect(q7, "(?<!-)hispanic"),
    race_white_alone = str_detect(q7, "white") & str_detect(q7, ";", negate = TRUE),
    
    #### location variables ####
    bronx_bi = borough == "bronx",
    brooklyn_bi = borough == "brooklyn",
    queens_bi = borough == "queens",
    
    #### income variables ####
    # income change variables
    inc_neg = q14 < q13,
    inc_pos = q13 < q14,

    inc_drop_med = q13 > median_inc & q14 <= median_inc, # change from greater than or equal to
    inc_drop_pov = q13 > poverty_line & q14 <= poverty_line, # change from greater than or equal to
    
    # income distribution before
    inc_dist = case_when(
      q13 <= poverty_line ~ 1, # change from less than
      q13 <= median_inc ~ 2, # change from less than
      TRUE ~ 3), # label them with haven
    
    # above or below median income before-hand
    inc_ab_med_before = q13 > median_inc,
    inc_be_med_before = q13 <= median_inc, # change from less than to less than or equal to
    
    # above or below median income afterward
    inc_ab_med_after = q14 > median_inc,
    inc_be_med_after = q14 <= median_inc,
    
    # below poverty line before and after
    inc_be_pov_before = q13 < poverty_line,
    inc_be_pov_after = q13 < poverty_line,
    
    # above median income both
    inc_ab_med = q14 > median_inc & q13 > median_inc,
    inc_be_med = q14 <= median_inc & q13 <= median_inc,
    
    #### employment variables ####
    wrk_in = str_detect(labelled::to_character(q19), "yes"),
    
    emp_status_before = case_when(
      str_detect(q15, "unemp") ~ "unemployed",
      str_detect(q15, "full|part|free|gig|small|home|student") ~ "employed",
      str_detect(q15, ";") ~ "multiple_other",
      TRUE ~ q15),
    
    emp_status_after = case_when(
      str_detect(q16, "unemp") ~ "unemployed",
      str_detect(q16, "full|part|free|gig|small|home|student") ~ "employed",
      str_detect(q16, ";") ~ "multiple_other",
      TRUE ~ q16),
    
    emp_change = q15 != q16,
    
    emp_before_part_time = case_when(
      q15_1 == 0 & any(q15_2 == 1, q15_3 == 1, q15_4 == 1, q15_5 == 1) ~ 1,
      q15_1 == 1 ~ 0
    ),
    
    #unemployed = emp_after == "unemployed", # newly unemployed # emp_un_after
    
    #### mental health variables ####
    ## q41_1 unable to control
    ## q41_2 confident about your ability
    ## q41_3 going your way
    ## q41_4 difficulties piling up
    
    mntl_hlth_bi = if_any(c("q41_1", "q41_4"), ~.>=3) | if_any(c("q41_2", "q41_3"), ~.<3),
    #across(contains("41"), ~!str_detect(haven::as_factor(.), "almost|never"), .names = "{col}_bi"),
    #final_clean %>% transmute(
    #across(c(q41_2, q41_3), ~labelled(.-1,attributes(final_clean$q41_3)$labels-1), .names = "{col}_rescale"),
    #across(c(q41_1, q41_4), ~labelled(1-.,1-attributes(final_clean$q41_4)$labels), .names = "{col}_rescale"),
    
    #mntl_hlth_state = rowMeans(across(ends_with("_rescale")), na.rm = TRUE),
    #mntl_hlth_state_bi = mntl_hlth_state < 0,
    
    across(c(q41_2, q41_3),
           ~labelled(5-.,5-attributes(final_clean$q41_3)$labels), .names = "stress_{col}"),
    across(c(q41_1, q41_4),
           ~labelled(.-1,attributes(final_clean$q41_4)$labels-1), .names = "stress_{col}"),
    stress_score = rowSums(across(starts_with("stress_"))),
    stress_bi = mean(stress_score, na.rm = TRUE) > stress_score,
    
    
    #### health variables ####
    ## q22_5 no insurance 
    ins_has = 1 - q22_5,
    
    #### covid variables ####
    ## q40 have your received the covid-19 booster?
    ## q38 tested positive?
    ## q43 concern over variants
    ## q39 vaccinated
    boost_bi = str_detect(labelled::to_character(q40), "yes|i plan"),
    boost_plan = str_detect(labelled::to_character(q40), "i plan"),
    
    posi_all = str_detect(labelled::to_character(q38), "yes"),
    
    vax_bi = ifelse(q39 == 3, NA, 2 - q39), # who preferred not to answer?
    
    vrnts_bi = q43 == 1,
    
    #### household variables ####
    ## q5 = age
    decade = paste0(floor(q5/10)*10, "s"),
    
    hh_65_bi = q25_1 >= 1, # fixed 
    hh_4_17_bi = q25_3 >= 1,
    hh_0_4_bi = q25_4 >= 1,
    hh_ch_0_17_bi = q25_3 >=1 | q25_4 >=1,
    hh_size = rowSums(across(starts_with("q25"))),
    hh_ad_one = q25_1 + q25_2 == 1,
    
    no_find_cc = str_detect(labelled::to_character(q30), "no\\b"),
    
    #### residence variables ####
    res_cat = labelled::to_character(q20),
    res_cat = case_when(
      str_detect(res_cat, "public") ~ "public",
      str_detect(res_cat, "owner") ~ "owner",
      str_detect(res_cat, "renter") ~ "renter",
      str_detect(res_cat, "not have") ~ "no permanent residence",
      TRUE ~ res_cat),
    
    #### education variables ####
    sch_level_cat = labelled::to_character(q12),
    sch_level_cat = case_when(
      str_detect(sch_level_cat, "high school|some college") ~ sch_level_cat,
      str_detect(sch_level_cat, "bach|ass") ~ "undergraduate degree",
      str_detect(sch_level_cat, "doct|mast|prof") ~ "graduate degree"
      ),
    
    sch_bach = factor(ifelse(str_detect(labelled::to_character(q12),
                                        "(?<!no )degree"), "BA plus", labelled::to_character(q12))),
    
    #### discrimination variables ####
    discrim_bi = q37 == 1 | q37 == 2,
    
    #### abuse or violence variables ####
    exp_ab_or_vi = str_detect(q36, "yes"),
    exp_ab_and_vi = str_detect(q36, "verbal abuse") & str_detect(q36, "physical violence"),
    
    #### concern variables ####
    ## q21_2 worried about running out of food
    ## q21_3 ran out of food
    ## q21_5 difficulty accessing cleaning supplies
    ## q21_6 difficulty accessing transportation
    ## q21_7 difficulty paying bills
    ## q21_8 difficulty paying rent
    ## q21_9 difficulty accessing housing
    ## q29 all concerns about child attending school
    
    con_num = as.integer(unlist(lapply(str_split(q29, ";"),
                                       function(item) if(!is.na(item)) {unlist(length(item))} else {NA}))),
    
    # at least two concerns about insecurity
    fin_unstable = q21_3 == 1 & q21_7 == 1 | q21_7 == 1 & q21_8 == 1 |
      q21_8 == 1 & q21_3 == 1,
    
    fin_insec = if_any(c("q21_2", "q21_3", "q21_7", "q21_8"), ~.== 1),
    
    # accessing resources
    diff_acc = if_any(c(q21_3, q21_9, q21_6, q21_5), ~.==1),
    
    # worried about running out or ran out of food
    food_insec = q21_3 == 1 | q21_2 == 1,
    
    #### rating variables ####
    ## q33_3 = rate government city
    
    rate_gov_cit_bad = q33_3 > 3,
    
    rate_gov_good = if_all(starts_with("q33"), ~.<3),
    rate_gov_bad = if_all(starts_with("q33"), ~.>3),
    rate_gov_ave = round(rowMeans(6 - across(starts_with("q33"))), digits = 4),
    
    rate_neigh_pub_good = q34_4 < 3,
    rate_neigh_pub_bad = q34_4 > 3,
    
    rate_neigh_pol_good = q34_8 < 3,
    rate_neigh_pol_bad = q34_8 > 3,
    
    rate_neigh_pre_good = q34_9 < 3,
    rate_neigh_pre_bad = q34_9 > 3,
    
    #### access variables ####
    lr_fam = if_any(starts_with("q35_") & ends_with("_5"), ~.==1),
    lr_gov = if_any(starts_with("q35_") & ends_with("_3"), ~.==1),
    lr_fb = if_any(starts_with("q35_") & ends_with("_1"), ~.==1),
    lr_np = if_any(starts_with("q35_") & ends_with("_2"), ~.==1),
    
    internet_lim = q23 != 1, # respondent has limited or no internet access
    internet_acc = q23 == 1
    
    
    ) %>%
  left_join(q41_bi)
  #mutate_at(vars(q20, q27), ~haven::as_factor(.)) #%>% sjlabelled::label_to_colnames() #%>%

to_label <- new_vars$var_name[new_vars$var_name %in% colnames(wrangled)]
new_vars_to_label <- lapply(to_label, function(col) {
  if(col %in% colnames(wrangled)) {
    index <- which(new_vars$var_name == col)
    values <- as.integer(unlist(stringr::str_split(new_vars$var_value[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(new_vars$var_label[index], "; "))
    named <- setNames(values, tags)
    out <- wrangled[col] %>% mutate_at(vars(col), funs(labelled(as.integer(.), named)))
    return(out)
  }
  
  #labelled(as.integer(wrangled[[col]]), named)
}) %>% reduce(bind_cols)

dim_before <- dim(wrangled)

wrangled[to_label] <- new_vars_to_label

dim_after <- dim(wrangled)
all.equal(dim_before, dim_after)

indeces <- which(column_names$q %in% colnames(wrangled))
key <- column_names$q[indeces]
value <- column_names$label[indeces]

names(wrangled)[match(key, names(wrangled))] <- value

# rename q41
indeces_41 <- which(str_detect(survey_codebook_labelled$q, "q41"))
key_41 <- paste0("stress_", survey_codebook_labelled$q[indeces_41])
value_41 <- paste0("stress_", survey_codebook_labelled$sub_label[indeces_41])
names(wrangled)[match(key_41, names(wrangled))] <- value_41

#wrangled <- wrangled %>%
#  fastDummies::dummy_columns("ny_resi_type", ignore_na = TRUE) %>%
#  fastDummies::dummy_columns("in_prsn_sch", ignore_na = TRUE) %>%
#  fastDummies::dummy_columns("concerns", ignore_na = TRUE)
wrangled$exp
#wrangled$q27 %>% table
wrangled %>% select(contains("36"))
wrangled %>% select(contains("41"))
?match
wrangled
# hispanic latino and black

sum(is.na(wrangled$exp_ab_and_vi))
mean(is.na(final_clean$q36))


weights <- wrangled %>% count(race = str_replace(race, ".*;.*", "two or more races")) %>%
  ungroup() %>% filter(!race %in% c("prefer not to answer", "other")) %>%
  mutate(actual = round(n/sum(n), digits = 3)) %>% left_join(census) %>%
  mutate(weight = target/actual) %>%
  mutate(weight = labelled(weight, setNames(weight, race)),
         `target/actual` = glue::glue("{target}/{actual}")) %>%
  select(race, n, target, actual, `target/actual`, weight)

wrangled

# extra NAs account for prefer not to answer and other
wrangled <-
  wrangled %>%
  mutate(race_census = str_replace_all(race,
                                       c(".*;.*" = "two or more races",
                                         "prefer not to answer|other" = NA_character_))) %>%
  left_join(select(weights, race, weight), by = c("race_census" = "race")) %>%
  fastDummies::dummy_cols("race_census") %>%
  rename(race_census_his_lat = `race_census_hispanic or latinx`,
         race_census_twomore = `race_census_two or more races`,
         race_census_black = `race_census_black or african american`,
         race_census_indian = `race_census_american indian or alaska native`,
         race_census_white = `race_census_white (non-hispanic or latino)`) %>% 
  select(-race_census_NA)
```


# save files

```{r}
today <- gsub("-", "", Sys.Date())

write_dta(wrangled %>% mutate(weight = as.numeric(weight)), path = paste0("../data/output/wrangled", today,".dta"))
saveRDS(wrangled, file = paste0("../data/output/wrangled", today, ".rds"))
write_excel_csv(wrangled, file = paste0("../data/output/wrangled", today, ".csv"))
write_excel_csv(weights, file = paste0("../data/output/weights", today, ".csv"))
```
