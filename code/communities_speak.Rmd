---
title: "Communities Speak"
author: "Arielle Herman"
date: "1/19/2022"
output:
  pdf_document: default
  html_document: default
---

```{r message=F, warning=F}
library(googledrive)
library(readxl)
library(tidyverse)
library(stringr)
library(haven)
library(rjson)
library(googlesheets4)
source("functions/fixup.R")
source("dictionary.R")
source("thresholds.R")
#source("compile.R")
readRDS("../data/processed/survey.rds")

  #select(-`Question Assignment_Temp_Column`, -`Survey Instrument Question #`)

#codebook
#bor_list <- c("brooklyn", "manhattan", "queens", "bronx", "si")
boroughs <- read_xlsx("../data/input/Borough_for_Arielle.xlsx") %>%
  rename_all(str_to_lower) %>% mutate_all(str_to_lower)# %>%
  #mutate(borough = factor(borough, levels = bor_list, labels = c(1:5)))



#survey <- read_csv("../data/input/individual_survey_eng_20220124_num.csv") %>%
#  mutate_all(str_to_lower) %>% rename_all(str_to_lower) %>% filter(!row_number() %in% c(1:2)) %>%
#  dplyr::select(responseid, contains("q"))

var_dict


survey <- readRDS("../data/processed/survey.rds")

#data_path <- "../data/input"
#files <- dir(path = data_path, pattern = ".csv")[c(-1, -3, -5)]
#survey <- files %>% map(~ read_csv(file.path(data_path, .), na = c("n/a", "N/A", "N/a", "n/a", "", " ", "Not applicable", "na","NA")) %>% filter(!row_number() %in% c(1,2))) %>%
  #reduce(bind_rows) %>% rename_all(str_to_lower) %>% mutate_all(str_to_lower) %>% 
  #rename(duration = "duration (in seconds)") %>% dplyr::select(responseid, duration, contains("q"), -q44, -q45)
                                 #rename_with(str_replace(.x, ".+", replacement = "_")))
                                 #rename_with(~glue::glue("q{as.integer(.x)+1}"),
                              #             .cols =  matches(paste(paste0("\\b", 1:9), collapse = "|"))))

```
```{r eval=F}
test %>% rename_at(vars(contains("[:digit:]") & !contains("Q")), ~paste0("q{.x}")) %>% select(contains("q"))

test %>% mutate_all(funs(glue::glue("q{.x}")))

# glue::glue("q{.x}")

colnames(test) %>% str_extract("[:digit:]{1,2}") %>% as.integer() + 1

test %>% select(!contains("TEXT")) %>% rename_with(~glue::glue("q{as.integer(.x)+1}"), .cols = matches(paste(paste0("\\b", 1:9), collapse = "|")))

test %>% select(`1`) %>% rename_with(~str_replace(.x, "[:digit:]{1}", "as.integer({.x})"), .cols = matches(paste(1:9, collapse = "|")))

lapply(function(file) rename_if(file, str_detect("[:digit:]") & !str_detect("q")), paste0("q", .))

q25 <- survey %>% select(contains("25")) %>% unlist
table(q25[str_detect(q25, "[:alpha:]")])

survey %>% select(contains("25")) %>% filter(if_any(everything(), ~str_detect(., "[:alpha:]")))
test_ids <- survey %>% select(responseid, q5) %>% mutate(test = str_detect(q5, "test")) %>% filter(test) %>% pull(responseid)
wrangled %>% filter(responseid %in% test_ids)
wrangled
```

# Var Dictionary
Combine with codebook in order to easily rename columns in the cleaned dataset

S# Survey Questions Codebook

Get important metadata on each of the questions that facilitates wrangling

# Data Cleaning

```{r visual_check, eval=F}
select(survey, contains("25")) %>% unlist %>% table
survey[likert] %>% unlist %>% table
survey[mavr] %>% unlist %>% table

survey["q5"] %>% table

age <- survey$q5
table(age[is.na(as.integer(age))]) # fix 83 1/2

hh <- select(survey, contains("25")) %>% unlist
table(hh[is.na(as.integer(hh))])

hh_clean <- survey %>% select(contains("25")) %>%
  mutate(across(everything(), ~as.integer(str_replace_all(., pattern = str_c(dict$pattern, collapse = "|"),
                                        replacement = fixup)))) %>% unlist
table(hh_clean[is.na(as.integer(hh))])
table(hh[is.na(as.integer(hh))])

survey %>% select(responseid, q5, contains("25")) %>% filter(q25_3 == "7ys")

hh_tests <- survey %>% select(responseid, contains("25"), "q5") %>%
  filter(if_any(c(contains("25"), "q5"), ~str_detect(., "[:alpha:]"))) %>% #filter(responseid == "r_t5xjhewkfw54k1p")
  mutate(across(contains("5"), ~str_replace_all(., pattern = str_c(dict$pattern, collapse = "|"),
                                                 replacement = fixup))) %>%
  mutate(across(contains("5"), ~as.double(str_extract(., "[:digit:]{1,2}"))))
  
survey %>% filter(responseid == "r_3pdurguqcvfee5l") %>% select(responseid, contains("25"), q5)

# validate response of respondent t6
survey %>% filter(age == "t6") %>% select(contains("25"))

test_clean <- clean_data() %>% select(responseid, contains("25"), q5) %>% filter(responseid %in% hh_tests$responseid)
hh_tests %>% left_join(survey %>%
                         select(responseid, q5, contains("25")) %>% filter(if_any(c(contains("25"), "q5"),
                                                                                  ~str_detect(., "[:alpha:]"))),
                       by = c("responseid")) %>% select(contains("25_4"))
# age u has completed some college and employment status
survey %>% filter(q5 == "u")
```


```{r}
clean_data <- function(df = survey, col = NULL) {
  by_col <- lapply(setdiff(colnames(df), c("responseid", "recordeddate")), function(col) {
    
    
#for (col in colnames(survey)[-1]) {
    index <- which(survey_codebook$q == col)
    values <- as.integer(unlist(stringr::str_split(survey_codebook$options[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(survey_codebook$choices[index], "; "))
    
    recode_na <- str_detect(tags, "not applicable")
    
    if(any(all.equal(values, c(1,2)) == TRUE, !is.na(recode_na) & recode_na)) {
      df[[col]] <- 2 - as.integer(df[[col]] %>%
                                    # hard code 3 - not applicable
                                    na_if("3"))
      values <- (2 - values) %>% na_if(-1)
      
    }
    
    named <- setNames(values, tags) %>% na.omit
    
    if(col %in% c(likert, simple)) {
      out <- df[c("responseid", col)] %>%
        mutate_at(vars(col), ~labelled(as.integer(.), named))
    
      # multiple answer  
    } else if(col %in% mavr){
      
      sym_col <- sym(col)
      out <- df[c("responseid", col)] %>%
        fastDummies::dummy_cols(col, split = ",", ignore_na = TRUE) %>%
        tidytext::unnest_tokens(output = !!sym_col, token = "regex",
                                input = col, pattern = ",") %>%
        mutate_at(col, ~factor(as.integer(.), levels = values, labels = tags)) %>%
        group_by(responseid) %>% mutate_at(col, ~paste(., collapse = ";")) %>%
        distinct %>% na_if("NA")
      
      
      # don't double count prefer not to answer
      if(any(str_detect(tags, "prefer not to answer"))) {
        pnta <- which(names(named) == "prefer not to answer")
        pnta_col <- paste(c(col, pnta), collapse = "_")
        out <- out %>% mutate_at(pnta_col,
                          funs(ifelse(str_detect(!!sym_col, "prefer not to answer;|;prefer not to answer"),
                                      0, !!sym(pnta_col)))) %>%
          mutate_at(col, ~str_replace(., "prefer not to answer;|;prefer not to answer", ""))
      }
      
      # haven label dummies
      cols_to_label <- out %>% ungroup %>% select_if(is.numeric) %>% colnames
      relabelled <- lapply(cols_to_label, function(dummy){
        i <- as.integer(str_replace(dummy, paste0(col, "_"), ""))
        values <- c(0, 1)
        names(values) <- c(paste("not", tags[i]), tags[i])
        out %>% ungroup %>% transmute_at(dummy, ~labelled(as.integer(.), values))
      }) %>% reduce(bind_cols)
      
      out[cols_to_label] <- relabelled
      
      #r_zaiyctblk6t1z33
    } else if(all(!str_detect(df[[col]], "[:alpha:]"), na.rm = TRUE) & any(!is.na(df[[col]]))) {
      out <- df[c("responseid", col)] %>% mutate_at(vars(col), as.integer)
    } else {
      out <- df[c("responseid", col)]  
    }
    
# print(col)   
#}    
    return(out)
  })
  
  by_col %>% reduce(full_join, by = c("responseid")) %>%
    ### replace specific patterns in age and household questions
    mutate_at(vars(contains("25"), "q5"), ~str_replace_all(., pattern = str_c(dict$pattern, collapse = "|"), replacement = fixup)) %>%
    ## transform age to double
    mutate(q5 = lapply(df[["q5"]], function(element){
      # average age range if provided instead of an age
      if(str_detect(element, "[:digit:]{2}.*[:digit:]{2}") & !is.na(element)) {
        round(mean(as.integer(unlist(str_split(element, "[:punct:]")))))
      } else {
      # remove text data and transform to integer 
        as.double(str_replace_all(element, "[:alpha:]|[:punct:]|\\+|\\>", ""))
      }
    }) %>% unlist) %>%
    ## transform household
    mutate(across(contains("25"), ~as.double(str_extract(., "[:digit:]"))))
  
}

survey
final_clean <- survey[c('responseid', 'recordeddate')] %>% left_join(clean_data()) %>% left_join(distinct(boroughs), by = c("q3" = "zipcode"))

# all NA if any NA
q35_sub <- final_clean %>% select(contains("35"))
q35_sub %>% transmute(mean = rowMeans(is.na(q35_sub))) %>% table


completion <- lapply(final_clean$responseid, function(id) {
#for(id in final_clean$responseid) {
  row <- final_clean[final_clean$responseid == id, ] %>% select(contains("q")) %>%
    select(!matches("_"), contains("q25"), q41_1, q35_1, q34_1, q33_1)
  
  # employment logic
  if(!str_detect(row$q16, "unemp") | is.na(row$q16)) { # respondents who didn't mark unemployed
    row <- row %>% select(-q17, -q18)
  } else if(labelled::to_factor(row$q17) != "yes") {
    row <- row %>% select(-q18)
  }
  
  # household with children logic
  if(sum(row$q25_3, row$q25_4, na.rm = TRUE) == 0) { # respondents that don't have children
    row <- row %>% select(-q26, -q27, -q28, -q29, -q30, -q31)
  } else if(str_detect(row$q26, "home") & !str_detect(row$q26, ";") | is.na(row$q26)) { # respondents that only selected home school
    row <- row %>% select(-q27, -q28)
  } else if(row$q27 == 0 | is.na(row$q27)) { # respondents whose children aren't attending school in person
    row <- row %>% select(-q28)
  }
  
  if(row$q39 != 1 | is.na(row$q39)) {
    row <- row %>% select(-q40)
  }
  # residence logic
  ## will need to disqualify respondents not just based on completion, but also...
  if(row$q2 == 0 & !is.na(row$q2)) { # goes to the end because it removes all the columns (can't test the other conditions)
    row <- row %>% select(q2)
  }
  
  completion <- mean(!is.na(row))
  return(completion)
}) %>% unlist

final_clean$completion <- completion

hist(final_clean$completion)
mean(!is.na(final_clean$q2))
save(final_clean, file = "../data/processed/final_clean.rdata")

```


```{r eval=F}
# validate calculation of completion rate
id <- final_clean %>% filter(
  #str_detect(q16, "unemp"),
  #labelled::to_factor(q17) == "yes"#,
  q25_3 + q25_4 > 0,
  !str_detect(q26, "home"),
  q27 == 0
) %>% #mutate(sum = q25_3 + q25_4) %>%
  #select(responseid, q27)
  pull(responseid) %>% .[[1]]

id <- final_clean %>% filter(q2 == 0) %>% pull(responseid) %>% .[[1]]
#final_clean %>% filter(responseid == "r_1ffk0gc9znaxxhh") %>% select(q3, borough)
#str(final_clean)
#getwd()
final_clean$q27
final_clean %>% filter(responseid == id) %>% select(q26)
final_clean$completion[final_clean$responseid == "r_3emaq9sygeqdfzy"]
#clean_data()

#write_csv(final_clean, "../data/processed/final_clean.csv")
#final_clean %>% select(contains("36"))
mavr
col = "q7"
df = survey
final_clean$q27
final_clean %>% filter(str_detect(q16, "unemp")) %>% select(responseid, q16, q17, q18)
final_clean %>% select(responseid, contains("25"))
final_clean %>% filter(completion >= 0.5) %>% nrow
final_clean$q25_3

mean(correct >= 0.4)
mean(sub_completion >= 0.4)

# confirm that if they didn't answer one of the likert, they didn't answer any
# 33, 34, 35, 41
final_clean %>% filter(if_any(contains("q35"), is.na)) %>%
  select(contains("q35")) %>% is.na %>% colMeans

test <- tribble(~test1, ~test2,
                NA_character_, "test3",
                "test4", "test5")

test %>% filter(if_any(everything(), is.na)) %>% is.na %>% colMeans
```


## Brief Cleaning Process Validation?

# Wrangle

```{r}

# 39
index_41 <- str_which(column_names$q, "q41")
key_41 <- column_names$q[index_41]
label_41 <- column_names$label[index_41]
q41_bi <- final_clean %>% select(responseid, source, contains("41")) %>%
  mutate_at(vars(contains("41")), ~!str_detect(haven::as_factor(.), "almost|never")) #%>% rename_at(vars(contains("41")), ~glue::glue("{.x}_bi"))
names(q41_bi)[match(key_41, names(q41_bi))] <- paste(label_41, "bi", sep = "_")

remove_test <- final_clean %>% filter(if_any(everything(), ~str_detect(.x, "^test$")))

wrangled <- final_clean %>% #mutate(completion = rowSums(!is.na(final_clean))/ncol(final_clean)) %>%
  # remove invalid responses
  filter(completion >= min_completion,
         duration >= min_duration,
         q2 == 1,
         q5 > 17,
         borough != "long island") %>%
  anti_join(remove_test) %>%
  # make new variables
  mutate(
    ## 6.2
    race_twomore = str_detect(q7, ";"),
    race_black_his = str_detect(q7, "black") & str_detect(q7, "(?<!-)hispanic"),
    race_white_alone = str_detect(q7, "white") & str_detect(q7, ";", negate = TRUE),
    ## 6.3
    #race_his_lat = str_detect(q7, "hispanic or latinx"),
    ## 6.4
    #race_afam = str_detect(q7, "black"),
    ## 13.2
    inc_neg = q14 < q13,
    ## 13.3 
    inc_dist = case_when(
      q13 < poverty_line ~ 1,
      q13 < median_inc ~ 2,
      TRUE ~ 3), # label them with haven
    ## 13.4
    inc_ab_med_b = q13 > median_inc,
    ## 13.5
    inc_be_med_b = q13 < median_inc,
    
    inc_ab_med_a = q14 > median_inc,
    
    inc_be_med_a = q14 < median_inc,
    
    inc_drop_med = q13 >= median_inc & q14 < median_inc,
    
    inc_be_med_b = q13 <
    
    ## 24.1
    hh_64_bi = q25_1 >= 1,
    hh_4_17_bi = q25_3 >= 1,
    hh_0_4_bi = q25_4 >= 1,
    ## 24.2
    hh_ch_0_17_bi = q25_3 >=1 | q25_4 >=1,
    
    # discrim
    discrim_bi = q37 == 1 | q37 == 2,
    
    ## 34.1
    exp_ab_or_vi = str_detect(q36, "yes"),
    exp_ab_and_vi = str_detect(q36, "verbal abuse") & str_detect(q36, "physical violence"),
    
    con_num = as.integer(unlist(lapply(str_split(q29, ";"), function(item) if(!is.na(item)) {unlist(length(item))} else {NA})))) %>% # make this an integer
  left_join(q41_bi)
  #mutate_at(vars(q20, q27), ~haven::as_factor(.)) #%>% sjlabelled::label_to_colnames() #%>%

to_label <- new_vars$var_name[new_vars$var_name %in% colnames(wrangled)]
new_vars_to_label <- lapply(to_label, function(col) {
  if(col %in% colnames(wrangled)) {
    index <- which(new_vars$var_name == col)
    values <- as.integer(unlist(stringr::str_split(new_vars$var_value[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(new_vars$var_label[index], "; "))
    named <- setNames(values, tags)
    out <- wrangled[col] %>% mutate_at(vars(col), funs(labelled(as.integer(.), named)))
    return(out)
  }
  
  #labelled(as.integer(wrangled[[col]]), named)
}) %>% reduce(bind_cols)

dim_before <- dim(wrangled)

wrangled[to_label] <- new_vars_to_label

dim_after <- dim(wrangled)
all.equal(dim_before, dim_after)

indeces <- which(column_names$q %in% colnames(wrangled))
key <- column_names$q[indeces]
value <- column_names$label[indeces]

names(wrangled)[match(key, names(wrangled))] <- value
#wrangled <- wrangled %>%
#  fastDummies::dummy_columns("ny_resi_type", ignore_na = TRUE) %>%
#  fastDummies::dummy_columns("in_prsn_sch", ignore_na = TRUE) %>%
#  fastDummies::dummy_columns("concerns", ignore_na = TRUE)
wrangled$exp
#wrangled$q27 %>% table
wrangled %>% select(contains("36"))
wrangled %>% select(contains("41"))
?match
wrangled
# hispanic latino and black

sum(is.na(wrangled$exp_ab_and_vi))
mean(is.na(final_clean$q36))


weights <- wrangled %>% count(race = str_replace(race, ".*;.*", "two or more races")) %>%
  ungroup() %>% filter(!race %in% c("prefer not to answer", "other")) %>%
  mutate(actual = round(n/sum(n), digits = 3)) %>% left_join(census) %>%
  mutate(weight = target/actual)

# extra NAs account for prefer not to answer and other
wrangled <-
  wrangled %>%
  mutate(race_weight = str_replace_all(race,
                                       c(".*;.*" = "two or more races",
                                         "prefer not to answer|other" = NA_character_))) %>%
  left_join(select(weights, race, weight), by = c("race_weight" = "race"))


remove_test$q44
```

# New Columns

```{r eval=F}

final_clean %>%
  #select(inc_b) %>%
  #select_if(haven::is.labelled) %>%
  labelled::generate_dictionary() %>% filter(pos == 4) %>%
  mutate(values = str_c(values, collapse = ",")) %>% .[["value_labels"]]
colnames(wrangled) %>% unique %>% length
#sapply(colnames(survey), function(col) table(survey[col]))


#final_clean %>% rename_all(~str_replace(., "q[:digit:]+_?[:digit:]?",
#                                        survey_codebook$var[. == survey_codebook$q]))

final_clean %>% filter(if_any(everything(), ~str_detect(.x, "fuck")))
```


# Upload files to google drive

```{r eval=F}
today <- gsub("-", "", Sys.Date())

write_dta(wrangled, path = paste0("../data/output/wrangled", today,".dta"))
saveRDS(wrangled, file = paste0("../data/output/wrangled", today, ".rds"))
write_excel_csv(wrangled, file = paste0("../data/output/wrangled", today, ".csv"))

googledrive_path <- "Communities Speak/Subteams/Data Subteam/Individual Survey-2(POA/Codebook/Census Figures)/cleaning/"

#write_excel_csv(survey_codebook, paste0("../data/codebook/survey_question_codebook_", today, ".csv"))
#drive_upload(media = paste0("../data/codebook/survey_question_codebook_", today, ".csv"),
#             path = paste0(googledrive_path, "data/survey_question_codebook_",
#                           today, ".csv"),
#             overwrite = TRUE, # for some reason, it is not effectively overwriting
#             type = "spreadsheet")

#drive_upload(media = "communities_speak.Rmd",
#             path = paste0(googledrive_path, "code/cleaning_script_", today, ".Rmd"),
#             overwrite = TRUE)
#drive_upload(media = "communities_speak.pdf", path = paste0(googledrive_path, "code/cleaning_script_", today, ".pdf"))
#drive_upload(media = "functions/fixup.R", path = paste0(googledrive_path, "code/functions/fixup.R"), overwrite = TRUE)
dim(wrangled)
```
