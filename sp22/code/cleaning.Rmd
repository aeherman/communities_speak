---
title: "Communities Speak"
author: "Arielle Herman"
date: "4/12/2022"
output:
  pdf_document: default
  html_document: default
---

```{r message=F, warning=F}
library(googledrive)
library(readxl)
library(tidyverse)
library(stringr)
library(haven)
library(rjson)
library(googlesheets4)
#source("functions/fixup.R")
source("default_setup.R")
source("functions/make_codebook.R")

files <- list.files("../data/processed", full.names = TRUE)
lapply(files[str_detect(files, "survey_codebook")], function(file) load(file, envir = .GlobalEnv))

#source("clean_data.R")
#setwd("~/communities_speak/sp22/code")
getwd()
source("functions/clean_data.R")

gs4_found <- gs4_find()

survey_id <- gs4_found %>% filter(str_detect(name, "Individual Survey- English - S22"),
                                  str_detect(name, "June")) %>% select(id, name)

survey <- read_sheet(survey_id$id, sheet = "Sheet1") %>%
  rename_all(stringr::str_to_lower) %>%
  rename(duration = "duration (in seconds)", order = fl_16_do) %>%
  filter(row_number() > 1) %>%
  select(responseid, recordeddate, duration, userlanguage, source,
         gc, aid,
         distributionchannel, order, matches("q"),
         -q_language) %>%
  mutate_at(vars(-recordeddate), ~str_to_lower(as.character(.))) %>% na_if("null") %>%
  unnest(recordeddate) %>% distinct %>%
  mutate(source = ifelse(is.na(aid), source, "eme"))

census <- gs4_found %>% filter(str_detect(name, "DECENNIALPL2020.P4-2022-05-24T145132")) %>% pull(id) %>%
  read_sheet(sheet = "table") %>%
  mutate(race = stringi::stri_trans_general(race, "latin-ascii") %>%
                   str_to_lower %>% str_replace(":|alone", "") %>% trimws) %>%
  filter(!is.na(cat)) %>% select(-cat) %>%
  arrange(race) %>%
  mutate(target = count/sum(count),
         label = c("indigenous american / first nations (including american indian or alaska native)",
                   "asian",
                   "black or african american",
                   "hispanic or latinx",
                   "native hawaiian or pacific islander",
                   "two or more races",
                   "other",
                   "white (non-hispanic or latino)"))

boroughs <- read_csv("../data/input/boroughs.csv") %>% distinct # question: why are there repeats for the same zipcode
```

# Var Dictionary
Combine with codebook in order to easily rename columns in the cleaned dataset

S# Survey Questions Codebook

Get important metadata on each of the questions that facilitates wrangling

# Data Cleaning


```{r}
final_clean <- survey[c('responseid', 'recordeddate')] %>% left_join(clean_data(df = survey)) %>%
  #filter(responseid == "r_1jthhnt6oyjloix") %>%
  left_join(boroughs, by = c("q3" = "zip")) %>%
  # fix the senior question by hand
  mutate(q26_1 = ifelse(q26_1 >= 65, 1, q26_1))

completion <- lapply(final_clean$responseid, function(id) {
#for(id in final_clean$responseid) {
  #id <- "r_1jthhnt6oyjloix"
  row <- final_clean[final_clean$responseid == id, ] %>% select(contains("q")) %>%
    select(!matches("_"), contains("q26"), q40_1, q35_1, q34_1, q33_1)
  
  
  # employment logic
  if(!str_detect(row$q16, "unemp") | is.na(row$q16)) { # respondents who didn't mark unemployed
    row <- row %>% select(-q18, -q19)
  } else if(any(is.na(row$q18), labelled::to_factor(row$q18) != "yes")) {
    row <- row %>% select(-q19)
  }
  
  # household with children logic
  if(sum(row$q26_3, row$q26_4, na.rm = TRUE) == 0) { # respondents that don't have children
    row <- row %>% select(-q27, -q28, -q29, -q30, -q31, -q32)
  } else if(str_detect(row$q27, "home") & !str_detect(row$q27, ";") | is.na(row$q27)) { # respondents that only selected home school
    row <- row %>% select(-q28, -q29, -q30)
  } else if(row$q28 == 0 | is.na(row$q28)) { # respondents whose children aren't attending school in person
    row <- row %>% select(-q29)
  }
  
  if(row$q44 == 1 | is.na(row$q44)) { # test logic
    row <- row %>% select(-q45, -q46)
  } else if(row$q45 != 1 | is.na(row$q45)) {
    row <- row %>% select(-q46)
  }
  
  # residence logic
  ## will need to disqualify respondents not just based on completion, but also...
  if(row$q2 == 0 & !is.na(row$q2)) { # goes to the end because it removes all the columns (can't test the other conditions)
    row <- row %>% select(q2)
  }
  
  completion <- round(mean(!is.na(row)), digits = 6)
  #print(id)
  return(completion)
}) %>% unlist

final_clean$completion <- completion

final_clean <- final_clean %>%
  mutate(test_response = if_any(everything(), str_detect, pattern = "^test$|beta_test")) %>%
  mutate(valid = case_when(
    completion > 0.5 & q2 == 1 & q5 > 17 & !is.na(borough) ~ 1,
    TRUE ~ 0
  )) %>%
  mutate(
    #yes_ny = q2 == 1,
    #complete = completion > 0.5,
    #plus_18 = q5 > 17,
    #borough_good = !is.na(borough),
    #test = if_any(everything(), ~str_detect(., pattern = "^test$")),
         source = ifelse(is.na(source), "communities speak", source),
    valid = ifelse(is.na(test_response), valid, NA_integer_),
    
    hh_size = rowSums(across(starts_with("q26"))),
    valid = ifelse(hh_size <= 20 | is.na(valid) | is.na(hh_size), valid, 0),
    # add one for people who responded that their age and not in that bracket
    q26_1 = ifelse(q5 >= 65 & q26_1 == 0, 1, q26_1),
    q26_2 = ifelse(q5 >= 18 & q5 < 65 & q26_2 == 0, 1, q26_2)) %>%
  select(responseid, recordeddate, duration, userlanguage, source, aid, order,
         completion, valid, test_response, borough, starts_with("q"))

#final_clean %>%
  #filter(responseid == "r_1dmcjaf6vuzlz2a") %>%
#  count(yes_ny, complete, plus_18, borough_good, valid, test, valid2)

hist(final_clean$completion)
mean(!is.na(final_clean$q2))
save(final_clean, file = "../data/processed/cleaned.rdata")
write_csv(final_clean, file = "../data/processed/cleaned.csv")
colMeans(is.na(survey))
colMeans(is.na(final_clean))

final_clean %>%
  select(responseid, userlanguage, q4) %>% na.omit() %>%
  filter(if_any(everything(), ~str_detect(., pattern = "^test$")))
```

## Brief Cleaning Process Validation?

# Wrangle

```{r}
wrangled <- final_clean %>% #mutate(completion = rowSums(!is.na(final_clean))/ncol(final_clean)) %>%
  # remove invalid responses
  filter(valid == 1) %>% select(-test_response) %>%
  # make new variables
  mutate(
    #### location variables ####
    # create binary for all of the boroughs
    bronx_bi = labelled::to_character(borough) == "bronx",
    brooklyn_bi = labelled::to_character(borough) == "brooklyn",
    queens_bi = labelled::to_character(borough) == "queens",
    
    #### transform binary variables ####
    across(c(q28, q31, q32), ~ifelse(. == 3, NA_integer_, 2 - .), .names = "{col}_bi"),
    
    #### income variables ####
    # income change variables
    inc_neg = q14 < q13,
    inc_pos = q13 < q14,

    inc_drop_med = q13 > median_inc & q14 <= median_inc,
    inc_drop_pov = q13 > poverty_line & q14 <= poverty_line,
    
    # income distribution before
    inc_dist = case_when(
      q13 <= poverty_line ~ 1,
      q13 <= median_inc ~ 2,
      TRUE ~ 3), # label them with haven
    
    # above or below median income before-hand
    inc_ab_med_before = q13 > median_inc,
    inc_be_med_before = q13 <= median_inc,
    
    # above or below median income afterward
    inc_ab_med_after = q14 > median_inc,
    inc_be_med_after = q14 <= median_inc,
    
    # below poverty line before and after
    inc_be_pov_before = q13 <= poverty_line,
    inc_be_pov_after = q14 <= poverty_line,
    
    # above median income both
    inc_ab_med = q14 > median_inc & q13 > median_inc,
    inc_be_med = q14 <= median_inc & q13 <= median_inc,
    
    #### employment variables ####
    wrk_in = str_detect(labelled::to_character(q20), "yes"),
    
    # work full-time; work part-time; freelance or consultant; gig worker (uber, lyft, instacart, etc.); small business owner; homemaker; student; retired; disabled; unemployed; other
    emp_status_before = case_when(
      str_detect(q15, "unemp") ~ "unemployed",
      str_detect(q15, "full|part|free|gig|small|home") ~ "employed",
      str_detect(q15, "student") ~ "student",
      str_detect(q15, ";") ~ "multiple_other",
      TRUE ~ q15), # students will be categorized
    
    emp_status_after = case_when(
      str_detect(q16, "unemp") ~ "unemployed",
      str_detect(q16, "full|part|free|gig|small|home") ~ "employed",
      str_detect(q16, "student") ~ "student",
      str_detect(q16, ";") ~ "multiple_other",
      TRUE ~ q16),
    
    emp_change = q15 != q16,
    
    emp_before_part_time = case_when(
      q15_1 == 0 & any(q15_2 == 1, q15_3 == 1, q15_4 == 1, q15_5 == 1) ~ 1,
      q15_1 == 1 ~ 0
    ),
    
    emp_after_part_time = case_when(
      q16_1 == 0 & any(q16_2 == 1, q16_3 == 1, q16_4 == 1, q16_5 == 1) ~ 1,
      q16_1 == 1 ~ 0
    ),
    #unemployed = emp_after == "unemployed", # newly unemployed # emp_un_after
    
    #### mental health variables ####
    ## q40_1 unable to control
    ## q40_2 confident about your ability
    ## q40_3 going your way
    ## q40_4 difficulties piling up
    
    across(c(q40_2, q40_3),
           ~labelled(5-.,5-attributes(final_clean$q40_3)$labels)),
    across(c(q40_1, q40_4),
           ~labelled(.-1,attributes(final_clean$q40_4)$labels-1)),
    stress_score = rowSums(across(starts_with("q40_"))),
    stress_bi = mean(stress_score, na.rm = TRUE) < stress_score,
    
    
    #### health variables ####
    ## q22_5 no insurance 
    ins_has = 1 - q23_5,
    
    #### covid variables ####
    ## q40 have your received the covid-19 booster?
    ## q38 tested positive?
    ## q43 concern over variants
    ## q39 vaccinated
    boost_bi = str_detect(labelled::to_character(q39), "yes"),
    #boost_plan = str_detect(labelled::to_character(q39), "i plan"),
    
    posi_all = str_detect(labelled::to_character(q38), "yes"),
    
    vrnts_ve = q43 == 1,
    vrnts_con = q43 %in% c(1, 2),
    
    #### household variables ####
    ## q5 = age
    decade = paste0(floor(q5/10)*10, "s"),
    
    hh_sn_65_bi = q26_1 >= 1, # fixed 
    hh_ch_4_17_bi = q26_3 >= 1,
    hh_ch_0_4_bi = q26_4 >= 1,
    hh_ch_0_17_bi = if_any(c(q26_3, q26_4), ~. >= 1),
    hh_ch_sn = if_all(c(hh_sn_65_bi, hh_ch_0_17_bi), ~. >= 1),
    #hh_ch_0_17_bi = q26_3 >=1 | q26_4 >=1,
    
    hh_size = rowSums(across(starts_with("q26"))),
    hh_ad_one = q26_1 + q26_2 == 1,
    
    # fix this third option: not applicable
    no_find_cc_bi = str_detect(labelled::to_character(q31), "no\\b"),
    # also need_Cc
    
    #### residence variables ####
    # fix this
    res_cat = labelled::to_character(q21),
    res_cat = case_when(
      str_detect(res_cat, "public") ~ 1,
      str_detect(res_cat, "owner") ~ 2,
      str_detect(res_cat, "renter") ~ 3,
      str_detect(res_cat, "not have") ~ 4
      ),
    
    #### education variables ####
    sch_level_cat = labelled::to_character(q12),
    sch_level_cat = case_when(
      str_detect(sch_level_cat, "high school|some college") ~ as.numeric(q12),
      str_detect(sch_level_cat, "bach|ass") ~ 4,
      str_detect(sch_level_cat, "doct|mast|prof") ~ 5
      ),
    
    sch_bach = ifelse(sch_level_cat <= 3, 0, 1),
    
    #### discrimination variables ####
    discrim_bi = q37 %in% c(1, 2),
    
    #### abuse or violence variables ####
    exp_ab_or_vi = str_detect(q36, "yes"),
    exp_ab_and_vi = str_detect(q36, "verbal abuse") & str_detect(q36, "physical violence"),
    
    #### concern variables ####
    ## q21_2 worried about running out of food
    ## q21_3 ran out of food
    ## q21_5 difficulty accessing cleaning supplies
    ## q21_6 difficulty accessing transportation
    ## q21_7 difficulty paying bills
    ## q21_8 difficulty paying rent
    ## q21_9 difficulty accessing housing
    ## q29 all concerns about child attending school

    att_con_num = as.integer(unlist(lapply(str_split(q30, ";"),
                                       function(item) if(any(!is.na(item))) {unlist(length(item))} else {NA}))),

    # at least two concerns about insecurity
    #fin_unstable = q21_3 == 1 & q21_7 == 1 | q21_7 == 1 & q21_8 == 1 |
    #  q21_8 == 1 & q21_3 == 1,
    # q22_2 diff_worr - worried about running out of food
    # q22_3 diff_ran_out
    # q22_7 diff_bill
    # q22_8 diff_rent
    # worried about running out or ran out of food
    food_insec = if_any(c(q22_3, q22_2), ~.==1),
    house_insec = if_any(c(q22_8, q22_9), ~.== 1),
    fin_insec = if_any(c(q22_2, q22_3, q22_7, q22_8), ~.== 1),
    
    # accessing resources
    res_insec = if_any(c(q22_3, q22_4, q22_5, q22_6, q22_9), ~.==1),
    
    
    #### rating variables ####
    ## q33_3 = rate government city
    
    rate_gov_fed_bad = q33_1 > 3,
    rate_gov_sta_bad = q33_2 > 3,
    rate_gov_cit_bad = q33_3 > 3,
    
    rate_gov_all_good = if_all(starts_with("q33"), ~.<3),
    rate_gov_all_bad = if_all(starts_with("q33"), ~.>3),
    rate_gov_all_ave = round(rowMeans(6 - across(starts_with("q33"))), digits = 4),
    
    across(c(q34_4, q34_5, q34_6, q34_8, q34_9), ~ . < 3, .names = "{col}_good"),
    across(c(q34_4, q34_5, q34_6, q34_8, q34_9), ~ . > 3, .names = "{col}_bad"),
    
    
    #### access variables ####
    lr_fam = if_any(starts_with("q35_") & ends_with("_5"), ~.==1),
    lr_gov = if_any(starts_with("q35_") & ends_with("_3"), ~.==1),
    lr_fb = if_any(starts_with("q35_") & ends_with("_1"), ~.==1),
    lr_np = if_any(starts_with("q35_") & ends_with("_2"), ~.==1),
    
    internet_lim = q24 != 1, # respondent has limited or no internet access
    internet_acc = q24 %in% c(1, 2),
    
    race_census = str_replace_all(q7,
                                  c(".*hispanic or latinx.*" = "hispanic or latinx",
                                    ".*;.*" = "two or more races",
                                    "prefer not to answer" = NA_character_))
    
    
    )

# naming

indeces <- which(survey_codebook_labelled$q %in% colnames(wrangled))
key <- survey_codebook_labelled$q[indeces]
value <- survey_codebook_labelled$full_name[indeces]

names(wrangled)[match(key, names(wrangled))] <- value

# naming q34
#indeces34 <- which(str_detect(survey_codebook_labelled$q, "34"))
#key34 <- survey_codebook_labelled$q[indeces34]
keyq_ <- colnames(wrangled)[str_detect(colnames(wrangled), "q[[:digit:]]{1,2}")]
key_split <- str_split(keyq_, "_(?=[[:alpha:]])")
pre <- unlist(lapply(key_split, first))
suf <- unlist(lapply(key_split, last))
#keyq <- str_replace(keyq_, "_[[:alpha:]]*$", "")
indecesq <- match(pre, survey_codebook_labelled$q)
valuesq <- survey_codebook_labelled$full_name[indecesq]
valuesq_ <- paste(valuesq, suf, sep = "_")
names(wrangled)[match(keyq_, names(wrangled))] <- valuesq_

# labeling
na_omit <- new_vars %>% na.omit()
to_label <- na_omit$var_name[na_omit$var_name %in% colnames(wrangled)]
new_vars_to_label <- lapply(to_label, function(col) {
  if(col %in% colnames(wrangled)) {
    index <- which(na_omit$var_name == col)
    values <- as.integer(unlist(stringr::str_split(na_omit$var_value[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(na_omit$var_label[index], "; ?"))
    named <- setNames(values, tags)
    out <- wrangled[col] %>% mutate_at(vars(col), funs(labelled(as.integer(.), named)))
    return(out)
  }
  
}) %>% reduce(bind_cols)

dim_before <- dim(wrangled)

wrangled[to_label] <- new_vars_to_label

dim_after <- dim(wrangled)
all.equal(dim_before, dim_after)
```

```{r}
lapply(select_if(wrangled, labelled::is.labelled), function(col) {
  label_values <- sort(as.integer(attributes(col)$labels))
  actual_values <- as.integer(sort(unique(col)))
  result <- all(actual_values %in% label_values)
  #result <- all.equal(label_values, actual_values)
  return(result)
}) %>% unlist %>% mean
```

# Weights

```{r}
weighted <- wrangled %>% count(race_census) %>%
  filter(!is.na(race_census)) %>% mutate(actual = n/sum(n)) %>%
  left_join(census, by = c("race_census" = "label")) %>%
  select(-count, -race) %>%
  mutate(`target/actual` = glue::glue("{target}/{actual}"),
         weight = target/actual,
         weight = labelled(weight, setNames(weight, race_census))) %>%
  arrange(weight)
```

Only to be applied once the survey is complete

```{r}
wrangled <- wrangled %>%
  left_join(select(weighted, race_census, weight), by = c("race_census")) %>%
  fastDummies::dummy_cols("race_census", ignore_na = TRUE) %>%
  rename(race_census_his_lat = "race_census_hispanic or latinx",
         race_census_twomore = "race_census_two or more races",
         race_census_black = "race_census_black or african american",
         race_census_ind =
           "race_census_indigenous american / first nations (including american indian or alaska native)",
         race_census_haw = "race_census_native hawaiian or pacific islander",
         race_census_white = "race_census_white (non-hispanic or latino)"
         )
```


# Save

```{r}
# data
today <- gsub("-", "", Sys.Date())
write_excel_csv(weighted, file = "../data/processed/weighted.csv")
write_dta(wrangled %>% mutate(weight = as.numeric(weight)),
          path = paste0("../data/output/wrangled.dta"))
saveRDS(wrangled, file = "../data/output/wrangled.rds")
write_excel_csv(wrangled, file = "../data/output/wrangled.csv")

# codebook
codebook <- make_codebook(wrangled) %>% arrange(as.integer(str_extract(q, "(?<=q)[[:digit:]]{1,2}")))
View(codebook)
getwd()
write_excel_csv(codebook, glue::glue("../data/output/codebook.csv"))

```

# Other validation

```{r}
dim(wrangled)
final_clean %>%
  filter(responseid == "r_2xdu5ggf7umy0f7") %>%
  filter(completion >= min_completion,
         duration >= min_duration,
         q2 == 1,
         q5 > 17,
         borough != "long island")

responseids <- final_clean %>% filter(#is.na(q5),
                       is.na(borough),
                       completion >= min_completion,
                       duration >= min_duration) %>% pull(responseid)

survey %>% filter(responseid %in% responseids)
final_clean %>% filter(responseid %in% responseids) %>% mutate_if(is.labelled, labelled::to_character)
```
